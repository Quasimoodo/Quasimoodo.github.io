<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Moby Dick</title>
    <url>/2022/05/24/About-Moby-Dick/</url>
    <content><![CDATA[<blockquote>
<p>现在，除了一艘轻轻摇晃的船赋予你的摇摆不定的生命，你没有生命；船的生命借自于大海；大海的生命借自于上帝神秘难测的潮汐。可是，当这睡眠，这幻梦将你笼罩，你的手或脚要是稍微挪动一下——你的双手彻底松开——你就会在惊恐中能够恢复自己的本性。你就盘旋在笛卡尔的涡流之上了。而也许，恰当正午，又是响晴的天气，你便随着一声半带窒息的尖叫，穿过透明的空气，坠入夏天的海洋，再也没有浮上来。好好留神吧，你们这些泛神论者！——《白鲸》桅顶瞭望</p>
</blockquote>
<blockquote>
<p>There is no life in thee, now, expect that rocking life imparted by a gently rolling ship; by her, borrowed from the sea; by the sea, from the inscrutable tides of God. But while this sleep, this dream is on ye, move your foot or hand an inch, slip your hold at all; and your identity comes back in horror. Over Descartian vortices you hover. And perhaps, at mid-day, in the fairest weather, with one half-throttled shriek you drop through that transparent air into the summer sea, no more to rise for ever. Heed it well, ye Pantheists! ——&lt;Moby dick&gt; CHAPTER 35 The Mast-Head</p>
</blockquote>
]]></content>
      <categories>
        <category>Metaphysics</category>
      </categories>
      <tags>
        <tag>Moby Dick</tag>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>SPT-Code</title>
    <url>/2022/05/27/SPT-Code/</url>
    <content><![CDATA[<p>这是《Sequence-to-Sequence Pre-Training for Learning Source Code Representations》的读书笔记</p>
<span id="more"></span>



<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>Pre-trained models 用于代码相关下游任务的应用时的 问题？</p>
<ol>
<li>仅用了Pre-trained encoder 但生成任务需要两个部件都预训练</li>
<li>现在许多Pre-trained model 包括T5，只是简单复用了NL的预训练任务，这要求NL-CODE的corpus 这使得数据受限</li>
</ol>
<p>为了应对这两个问题 提出了SPT-Code ，在微调后可以在5个代码相关任务上SOTA</p>
<p>这是一个seq2seq 预训练模型，通过三个预训练任务使得其能够学习到下面三点，并在下游任务中使用</p>
<ul>
<li>代码知识</li>
<li>对应代码结构</li>
<li>自然语言描述</li>
</ul>
<p>而不需要双语corpus</p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>作者在第一部分提了自监督训练，然后说预训练模型的成功和这个有关系，下面谈预训练模型到软工SE任务的时候认为的问题是：</p>
<ul>
<li><p>主流预训练模型仅对encoder搞 ，不够理想</p>
<p>最有名的encoder也就是BERT吧 也确实就是用了MLM（Masked Language Modeling） 也确实有好多Pre-trained Bert 下面套个任务头或者另一个decoder就开干的……不过这应该算是蛮荒时代了 T5虽然好 但是对一般研究人员来说想改进模型architecture 不是那么容易？</p>
<ul>
<li><p>别人的解决：</p>
<p>T5-learning , TreeBERT 两个工作使得Encoder-Decoder jointly trainded</p>
</li>
</ul>
</li>
<li><p>这些预训练模型预设输入的是NL-CODE 忽视了代码结构</p>
<p>为什么呢？因为就是简单偷了NLP的拿来用</p>
<ul>
<li><p>别人的解决：</p>
<p>专门的预训练任务 包括预测数据流图中的边与对齐节点和代码 </p>
<p>——dataflow 有语义信息而无语法信息（AST）</p>
</li>
</ul>
</li>
<li><p>而且都假设有严格对齐的双语语料</p>
<ul>
<li><p>T5-learning :</p>
<p>分别处理两种输入，不要求语料库中展示二者的关系</p>
</li>
</ul>
</li>
</ul>
<p>—— 没有一个模型能够统一处理这三个问题</p>
<p>SPT-Code就可以！</p>
<ul>
<li>这是一个encoder-decoder共同预训练的模型</li>
<li>数据实例由CODE,AST,NL三部分构成</li>
<li>使用方法名和调用此方法的方式作为自然语言描述（以避免对bilingual corpus的依赖）</li>
</ul>
<p>方法：</p>
<p>设计了三种预训练任务，每一种获取一种数据信息</p>
<ul>
<li>改进的MASS-用于CODE：遮蔽Seq2Seq恢复</li>
<li>Code-AST Predict CAP：预测code-AST是否匹配</li>
<li>Method Name Generation MNG：生成 方法名的 子token</li>
</ul>
<p>数据集：</p>
<p>CodeSearchNet</p>
<p>贡献：</p>
<ol>
<li>提出了SPT-Code预训练模型，可用于分类和生成任务</li>
<li>使用了线性和简化的AST 第一个使用了NL&amp;AST作为输入对于预训练</li>
<li>通过输入表示和三个与训练任务使得预训练模型不依赖双语语料库（labeled data)</li>
<li>用未标注数据库在五个下游任务实现了SOTA</li>
</ol>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>架构，输入和预训练任务，微调</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>类似于BART和T5的典型Transformer</p>
<p>分类任务和生成任务，模型采用相同的输入：</p>
<ul>
<li>分类对encoder和decoder输入相同</li>
<li>生成采用传统方法</li>
</ul>
<img src="/2022/05/27/SPT-Code/image-20220527230530594.png" alt="image-20220527230530594" style="zoom:50%;">

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><img src="/2022/05/27/SPT-Code/image-20220527231806850.png" alt="image-20220527231806850" style="zoom:50%;">

<p>由三部分组成，每一部分[SEP]连接</p>
<h3 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h3><p>没有使用笨蛋tokenizer，而是用了stl for Python 或者 antlr for Java,Php.etc 其他的用了NLTK</p>
<h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p>用的Tree-sitter 搞的 AST </p>
<p> 如何序列化AST?</p>
<ul>
<li><p>传统方法：SBT （Structure-Based Traversal)</p>
<p>比先序遍历之类的更有效，但可能产生过长的序列（可能超过代码三倍长）</p>
<img src="/2022/05/27/SPT-Code/image-20220527232629535.png" alt="image-20220527232629535" style="zoom:50%;">

<center>
    一种类似中序遍历的说法 来自那篇论文忘了 反正绝对看过
</center>

</li>
<li><p>本文的方法：X-SBT：XML-like SBT</p>
<p>可以减少超过一半的长度</p>
<img src="/2022/05/27/SPT-Code/image-20220527233143119.png" alt="image-20220527233143119" style="zoom:67%;">

<p>论文自带的图好看一点 这个创新点……只能说是情理之中，毕竟原来那个也太呆了（作者甚至还装模做样证了一下必然更短）</p>
<p>为了更短: AST——XSBT时，仅取表达式级别以上节点，放弃终结符</p>
<img src="/2022/05/27/SPT-Code/image-20220527233752649.png" alt="image-20220527233752649" style="zoom:50%;">

<p><strong>这种优化为可接受的，为什么呢？下面这个说得很漂亮：</strong></p>
<p>AST中包含了语法信息和词法信息，舍弃掉终结符丢失了词法信息，但之前的token（Input中Code的部分）都是词法单元，所以这个信息是没有丢掉的，因此改进可接受</p>
</li>
</ul>
<h3 id="NL"><a href="#NL" class="headerlink" title="NL"></a>NL</h3><p>难点：从仅有CODE中提取NL</p>
<p>方法：获取方法名与调用的API序列</p>
<p>对驼峰和下划线命名掰开</p>
<p>问题：怎么提取的API序列：从AST里偷出来的？</p>
<p>——应该就是</p>
<h2 id="预训练任务"><a href="#预训练任务" class="headerlink" title="预训练任务"></a>预训练任务</h2><p>𝐼𝑛𝑝𝑢𝑡 &#x3D; 𝐶,[SEP],𝐴,[SEP],𝑁 </p>
<h3 id="Code-AST-Prediction"><a href="#Code-AST-Prediction" class="headerlink" title="Code-AST Prediction."></a>Code-AST Prediction.</h3><p>这是第一个</p>
<p>在构建输入𝐼𝑛𝑝𝑢𝑡 时，一半是对应的AST,一半是随机的AST</p>
<h3 id="MASS"><a href="#MASS" class="headerlink" title="MASS"></a>MASS</h3><p>随机遮蔽C中的一部分，将所有遮蔽的token设置为[MASK]（改进前为对应数量个[MASK])</p>
<p>根据别人的论文，最大遮蔽长度是C长度l的一半</p>
<h3 id="Method-Name-Generation"><a href="#Method-Name-Generation" class="headerlink" title="Method Name Generation"></a>Method Name Generation</h3><p>希望可以通过这个任务学到代码的动机</p>
<p>代码名的词汇和对应代码总结的词汇由高度相关，因此希望通过改善 预测代码名 这一任务提升 代码总结 的能力</p>
<p>此任务的输入时，从𝐼𝑛𝑝𝑢𝑡中的C扣掉对应token，并在N中去掉前s个token（方法名总在最前），作为输入，试图让decoder输出扣掉的前s个token，即方法名</p>
<h2 id="微调"><a href="#微调" class="headerlink" title="微调"></a>微调</h2><p>端到端 根据不同任务分成两类，分类或生成，不同任务就缺掉一点输入</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h2><p>交代了数据集的数据使用，任务顺序，epoches，用的cross-entropy loss和Adam-W，batchsize和显卡（……）</p>
<p>Tokenizer Encoding 用的BPE对CODE和NL，在预训练data上干过 每个下游任务照用</p>
<p>预训练任务的任务量都是每个任务几十个Epoches的量级。</p>
<p>问题：不是都有token了 还tokenize？</p>
<p>——低级问题，前面的应该是tokenize，这里进行token&#x3D;&gt;input_ids的步骤</p>
<h2 id="下游任务微调"><a href="#下游任务微调" class="headerlink" title="下游任务微调"></a>下游任务微调</h2><p>介绍了五个任务 其中介绍部分有点尴尬</p>
<h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><p>RQ1:相比于其他较好的基线 这个性能在下游任务如何？</p>
<p>列个表 比不上人家的扯一点</p>
<p>RQ2:三个预训练任务对五个下游任务分别有什么贡献？</p>
<p>——消融实验</p>
<p>有趣的是 删除掉MNG （生成 方法的token）在代码完成和代码修复上性能有所提高：</p>
<ul>
<li>MNG是目标自然语言的预训练，而这两项任务都是代码到代码</li>
</ul>
<p>分析一下 什么任务对什么下游有影响</p>
<p><strong>稍微有点水平的问题</strong></p>
<p>RQ3: 可以利用更多无标记的资料是不是本模型的优点呢？</p>
<p>相较于别的预训练模型，由于它的设计，可以使用无标注数据。更好的性能是不是来自于更多的数据呢？（而不是模型本身厉害？）</p>
<p>在同样的数据集上训练——把它当作无标注的——其实和别的比还算吃亏——也能够取得相对别的模型更好的结果。</p>
<p>可以说是赢两遍了。</p>
<p>RQ4:微调阶段的数据量对下游任务有什么影响？</p>
<p>虽然越小越坏，但是很小也和别的模型差不多 说明真好</p>
<h2 id="定性分析与定量分析"><a href="#定性分析与定量分析" class="headerlink" title="定性分析与定量分析"></a>定性分析与定量分析</h2><p>定量：志愿者评估，多个样本分类列表个</p>
<p>定性：在哪些任务哪些方面表现好 不好的怎么不好</p>
<h1 id="威胁分析"><a href="#威胁分析" class="headerlink" title="威胁分析"></a>威胁分析</h1><p>构造：数据集可能有重复</p>
<p>内部：没调过超参数：所以可能有更好的</p>
<p>外部：只用了CodesearchNet</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>我们介绍了SPT-Code，这是一个基于编码器架构的源代码的大型型号。首先，我们为预训练SPT代码设计了三个特定代码的预训练任务。其次，我们提出了一种新的输入表示形式，它是第一个考虑自然语言和AST形式的方法，我们还提出了AST遍历方法的改进版本XSBT。我们的预训练任务和输入表示形式都允许在完全未标记的数据集上预先训练SPT代码。然后，对五个与代码相关的下游任务进行了微调。结果表明，微调SPT代码使其能够在五个与代码相关的下游任务上实现最新性能。消融实验表明，这三个预训练任务对不同的下游任务具有不同程度的影响，AST和自然语言输入也有助于提高SPTCODE的性能。为了促进未来的研究，我们还可以在<a href="https://github.com/">https://github.com/</a> nougatca&#x2F;spt-code上公开提供代码和其他。</p>
]]></content>
      <categories>
        <category>Substance</category>
      </categories>
      <tags>
        <tag>ICSE 2022</tag>
        <tag>Code generation</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>Philip Larkin 诗鉴赏</title>
    <url>/2022/06/05/Philip-Larkin/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天读到了Philip Larkin(菲利普·拉金) 觉得他确实写出了一些人类的共有困境，是超越东西方的 也不好说是现代视角或者古典视角。用诗歌描述一种……symptom？没有意象的堆叠或者是故作惊人之语。恰到好处的建筑与音韵意识又不喧宾夺主，克制的情感流露并着个人色彩。 类似于散文诗？</p>
<span id="more"></span>
<p>现摘在这里这一首，「Love Songs in Age」<br>She kept her songs, they kept so little space,<br>The covers pleased her:<br>One bleached<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="floating, drift,漂白
">1</span></a></sup> from lying in a sunny place,<br>One marked in circles by a vase of water,<br>One mended<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="repair,patch,修补
">2</span></a></sup>, when a tidy fit had seized her,<br>And coloured, by her daughter -<br>So they had waited, till, in widowhood<br>She found them, looking for something else, and stood</p>
<p>Relearning how each frank submissive chord<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="和弦
">3</span></a></sup><br>Had ushered<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="（迎宾员式的）引导
">4</span></a></sup> in<br>Word after sprawling hyphenated<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="连字符
[^6 ]:great brightness,耀眼的
">5</span></a></sup> word,<br>And the unfailing sense of being young<br>Spread out like a spring-woken tree, wherein<br>That hidden freshness sung,<br>That certainty of time laid up in store<br>As when she played them first. But, even more,</p>
<p>The glare<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label>6</span></a></sup> of that much-mentionned brilliance, love,<br>Broke out, to show<br>Its bright incipience<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="beginning to exist or to be apparent
">7</span></a></sup> sailing above,<br>Still promising to solve, and satisfy,<br>And set unchangeably in order. So<br>To pile them back, to cry,<br>Was hard, without lamely<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="in a weak and unconvincing manner">8</span></a></sup> admitting how<br>It had not done so then, and could not now.</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">floating, drift,漂白<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">repair,patch,修补<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">和弦<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">（迎宾员式的）引导<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">连字符
[^6 ]:great brightness,耀眼的<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">beginning to exist or to be apparent<a href="#fnref:7" rev="footnote">↩</a></span></li><li id="fn:8"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">in a weak and unconvincing manner<a href="#fnref:8" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
      <categories>
        <category>Metaphysicsk</category>
      </categories>
      <tags>
        <tag>Poem</tag>
        <tag>Literary criticism</tag>
        <tag>Philip Larkin</tag>
      </tags>
  </entry>
  <entry>
    <title>Follow Ace Taffy Meow！</title>
    <url>/2022/05/23/testpic/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Follow Ace Taffy thanks Meow!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/05/23/testpic/image-20220524021029166.png" alt="image-20220524021029166"></p>
]]></content>
      <categories>
        <category>Meow</category>
      </categories>
      <tags>
        <tag>Ace</tag>
        <tag>Taffy</tag>
      </tags>
  </entry>
  <entry>
    <title>火柴</title>
    <url>/2022/05/29/%E7%81%AB%E6%9F%B4/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我在<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="火柴梗快要烧完的时候，会因为火焰过分接近而忍不住松手">6</span></a></sup>水中桥下<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="「尾生與女子期於梁下，女子不來，水至不去，抱樑柱而死。」《莊子·盜跖》
">1</span></a></sup> 饮酒<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label=" 「夢飲酒者，旦而哭泣；夢哭泣者，旦而田獵。方其夢也，不知其夢也。」《莊子·齊物論》
">2</span></a></sup>&#x2F;<del>忘相泉涸<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="「泉涸，魚相與處於陸，相呴以溼，相濡以沫，不如相忘於江湖。」《莊子·大宗師》">4</span></a></sup>前日的红烛<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="「蠟炬成灰淚始幹」 李商隐
">5</span></a></sup>泪眼<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="「文侯與虞人期獵。是日，飲酒樂，天雨。文侯將出，左右曰：「今日飲酒樂，天又雨，公將焉之？」文侯曰：「吾與虞人期獵，雖樂，豈可不一會期哉！」乃往，身自罷之。」《戰國策·魏策》
">3</span></a></sup></del>红烛淡忘镜中的泪眼</p>
<p>自己写完还解诗的人肯定是天下第一无聊 但这只不过是记录灵感媾和时的一些脉络和取舍。</p>
<span id="more"></span>


<hr>
<p>2022&#x2F;5&#x2F;30日凌晨睡不着床上对后半句做了修正</p>
<p>第二天起来看前天写得也太迫真了 简直就是笨蛋版本李商隐</p>
<p>当时是怎么想的呢？「忘相」是什么表达？生怕别人看不出来是你直接从庄子里偷来的？「泉涸」同理，太白太直了 反而失去了解读空间。「前日」也不明所以的。都要删掉。「红烛泪眼」是核心意象要留下来。</p>
<p>想要留下来的是什么呢？遗忘肯定是要有的，这是我给出的解答。互相也是要有的，起源就是由防风火柴想到的尾生抱柱抛出的一问。「红烛泪眼」没法共轭，还是拆开好了。</p>
<p>互相的话 就用镜子好了。破妄，吊诡，空间的拓展却又重复，自反中带有异质性。很好。</p>
<p>「红烛在镜中总是泪眼」？当时还开心的把手机翻出来赶紧记下，记完想想又觉得不好 啰啰嗦嗦的。</p>
<p>「红烛向镜中抛去泪眼」？我很喜欢这个动作带有的力量感，和伴随而来的主体性。用什么迎接你？以眼泪，以沉默。这是有力量的沉默。但是汉语还是半通不通的 忘记也没了。不好。</p>
<p>「忘记」这个字其实很好，自反又偏义，但是口语中用得太多了 读来感觉不到妙处 不好。</p>
<p>我想，烛火燃烧时上腾的青烟，蒸腾的雾气凝结成雨，落下化为沙尘，恰好就有一种复调式的演出效果。水汽也好，腾烟也好，怎么放在这里处理”忘“这个要素呢？想到了溶解，融化，但都用不好。这里卡了很久没想出来。</p>
<p>灵光一闪，就用「淡忘」。「淡」字自己就好像是拿来给水墨化开的，要是到token级别就是又有水又有火的自反，不管是前句的湖中还是镜子都能超距作用。「淡忘」本来不是什么僻词，但放在这里就妙得没话说。</p>
<p>「红烛淡忘镜中的泪眼」，真好。</p>
<p>「我」「饮酒」，「烛」「忘眼」。好像比兴一样的氛围，又构成了复调的演奏。「水」与「镜」，「泪」与「眼」，几乎每一个元素都能够进行笛卡尔式呼应。比兴之中，阅读顺序的先后带来的时序性还为文本增添了并列以外的递进因素，自问自答。很好。我很喜欢。</p>
<p>如果说昨天是向义山一样堆叠典故，这次就是处理意象了，也是很好玩呐。</p>
<p>下面又试着加点东西。一方面是平衡语感。这两句佶屈聱牙，像极了祭祀用的七言律诗，但是要是能像冯君一样，神神叨叨念完“长剑归来乎，”，令人不容小觑，立马接上一句“食无鱼”产生节目效果。那就可以说是非常成功了。</p>
<p>此外，也和我想要追求的吊诡氛围有点差异。水中饮酒还有镜子，好像是月光下的水晶湖一样，太明亮通透了些&#x2F;</p>
<p>加什么呢？四个字的好。「烟波浩渺」？我想到洞庭湖，蹭蹭湘君的隐喻正好在调上。「烟涛微茫」？直接偷过来好像也不坏。像是舞台布景的话，很明白的小舞台放在巨大的烟幕里，也是那个意思。</p>
<p>不过怎么放怎么感觉不妙，况且下来也不知怎么接手。先这么放着好了。<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">「尾生與女子期於梁下，女子不來，水至不去，抱樑柱而死。」《莊子·盜跖》<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">「夢飲酒者，旦而哭泣；夢哭泣者，旦而田獵。方其夢也，不知其夢也。」《莊子·齊物論》<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">「文侯與虞人期獵。是日，飲酒樂，天雨。文侯將出，左右曰：「今日飲酒樂，天又雨，公將焉之？」文侯曰：「吾與虞人期獵，雖樂，豈可不一會期哉！」乃往，身自罷之。」《戰國策·魏策》<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">「泉涸，魚相與處於陸，相呴以溼，相濡以沫，不如相忘於江湖。」《莊子·大宗師》<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">「蠟炬成灰淚始幹」 李商隐<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">火柴梗快要烧完的时候，会因为火焰过分接近而忍不住松手<a href="#fnref:6" rev="footnote">↩</a></span></li></ol></div></div></p>
]]></content>
      <categories>
        <category>Metaphysics</category>
      </categories>
      <tags>
        <tag>Poem</tag>
        <tag>Self</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记 Automated Generation of Constraints From Use Case Specifications to Support System Testing</title>
    <url>/2022/06/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Automated-Generation-of-Constraints-from-Use-Case-Specifications-to-Support-System-Testing/</url>
    <content><![CDATA[<p>后记：</p>
<p>这篇文章真没搞懂 看的时候觉得实在有点车轱辘话嗯说 前面说UMTG只要RUCM和OCL 后面说OCLgen的输入还需要类图……</p>
<p>前面说verbnet里也不全是同义词 后面又说都是同义词</p>
<p>前面说这个可以转换所有语言 后面就是简单推测了一下用较少规则可以转换好多 而现在还只实现了较少的较少……</p>
<p>当然 也可能是我水平还不够看得颠三倒四 总之 就只是把他非常「作为手段地」分析了一通</p>
<span id="more"></span>

<ul>
<li><p>这篇文章要解决什么问题？</p>
<ul>
<li>需要从自然语言的需求规范中自动生成可执行测试用例，使用UMTG工具</li>
<li>UMTG需要的东西：RUCM的自然语言规范和OCL写的约束</li>
<li>OCLgen就要生成OCL约束——主要是前后置条件</li>
</ul>
</li>
<li><p>OCLgen的输入输出是什么？</p>
<ul>
<li>输入：UMTG一致(?)——RUCM的NL和UML类图的系统领域模型</li>
<li>输出：每一个用例步骤对应的OCL约束</li>
</ul>
</li>
</ul>
<p><img src="/2022/06/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Automated-Generation-of-Constraints-from-Use-Case-Specifications-to-Support-System-Testing/image-20220628194141482.png" alt="image-20220628194141482"></p>
<img src="/2022/06/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Automated-Generation-of-Constraints-from-Use-Case-Specifications-to-Support-System-Testing/image-20220628194155803.png" alt="image-20220628194155803" style="zoom: 33%;">

<ul>
<li><p>它厉害在哪里？</p>
<ul>
<li>别人的方法 要使用CNL（受控的自然语言）来写软件要求，即，采用有限的动词</li>
<li>他的方法——需要UMTG格式的语言——但不限制动词，还需要类图</li>
<li>在测试的工业案例中，可以达到75%的正确</li>
<li>使用了语义标注和同义词合并的方法，使得只需要很少的规则就可以实现大范围的转换</li>
</ul>
</li>
<li><p>他的方法是什么？</p>
<ul>
<li>先用SRL（语义角色标注）标记句子中词汇的角色</li>
<li>识别到之后 根据一定的规则再去识别类或自然语言中之中别的属性和操作符</li>
<li>还有通用的——元动词转换规则——因为目的是生成测试用例</li>
<li>然后（如果能生成多个）就打分评估最好的输出</li>
<li>打分方法：完整性和正确性——用例中角色在OCL中出现的比例，变量名和用例名一致(<strong>这里完全没搞懂</strong>)</li>
</ul>
</li>
<li><p>他的评估方法是什么？</p>
<ul>
<li>比较了生成的和手动编写的 比较了正确率</li>
<li>对于需求 说了87个测试中生成除了多少</li>
<li></li>
</ul>
</li>
<li><p>他的不足在哪？</p>
<ul>
<li>聚焦于前后置条件 主要测试场景就是这个工业案例 所以对输入有预设，对输出有范式</li>
<li>吹得很猛 不需要限制 可以处理所有 其实目前只实现了7类规则，可以处理408个动词</li>
<li>对语言的规格还是有需求 需要输入UML类图</li>
<li>实验很弱</li>
</ul>
</li>
<li><p>有什么启发？</p>
<ul>
<li>比较的时候 应用场景 生成的灵活性都会比他好不少</li>
<li>对于方案设计启发不大</li>
</ul>
</li>
</ul>
<p>目的：</p>
<p>从自然语言的需求规范中自动生成系统测试用例</p>
<p>——》</p>
<p>为UMTG生成其需要的正则标准，提出了OCLGEN</p>
<p>使用语义分析技术来识别用力规范的前后置条件</p>
<p>可以75%正确生成前后置条件</p>
<p>系统测试很重要 其测试用例要展示功能和安全需求，</p>
<p>软件需求用NL写，然后由工程师手动转换，昂贵且易错</p>
<p>现有的自动化解决方案依靠限制过的，简单的自然语言解决</p>
<p>别人的方法（生成测试用例的）：</p>
<p>基于特殊关键词侦测，如 if then&#x3D;&gt;抽象，高层次 给测试人员</p>
<p>用受控的自然语言(CNL)写软件规格,再基于规则转换为正则标准&#x3D;&gt;可用语言非常有限</p>
<p>不用CNL 但需要其他的建模工作——UMTG就是这样的</p>
<p>OCLgen——捕获语句中的后置条件或前置条件——采用了文本转换规则，依赖自动语义分析技术，无需受控语言</p>
<p>SRL（语义角色标注）实现词汇的标注，例如，收到动作最直接影响的成员就应该出现在后置条件中</p>
<p>同义词识别，判断不同的词汇能否用相同的规则处理</p>
<p>在测试的工业案例中，75%精度，25%由于精度不足</p>
<p>UMTG: RUCM(用于写用例的一种语言格式 基本流替代流什么的)+OCL——测试用例</p>
<p>语义标注：搞清楚短语的角色对前后置条件的生成是必要的</p>
<p>别人搞的自然语言-用例生成不少用了语法识别 有一定用但搞不清短语作用</p>
<p>SRL有许多种 但用了CNP是因为他是唯一一个还在积极开发的 也有接口</p>
<p>同义检测：</p>
<p>VerbNet不仅包括同义词类，还包括模式，如主语+不及物或主系表结构 </p>
<p>使用了和PropBANK(CNP使用的）不同的模型，也会有不同的标签，但存在映射关系</p>
<p>同一类中的词共用一种模式，帮助定义可重用的转换规则，但不是同一类中的都是同义词（？）用来识别同义词最先进的方法是WordNet</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>UMTG需要人写ocl捕获这两种信息：</p>
<ul>
<li>行动对于系统状态的影响——后置条件</li>
<li>用例的前置条件</li>
</ul>
<p>OCLgen就要自动化这一步骤</p>
<p>需要的输入与UMTG一致：</p>
<ul>
<li>RUCM写的用例规范</li>
<li>以UML类图形式的 系统的领域模型</li>
</ul>
<p>可以输出每一个用例步骤对应的OCL约束</p>
<p>OCLgen的方法：</p>
<ul>
<li>通过SRL<ul>
<li>挑选要出现在约束中的元素，</li>
<li>决定要使用的比较运算符</li>
<li>额外的操作符，如否定</li>
</ul>
</li>
<li>针对每一个动词 使用不同转换规则转换——为了可行，使用VerbNet合并词类，需要的规则更少</li>
</ul>
<p>转换步骤：</p>
<p>标记——选择规则——转换候选——挑选最高分</p>
<p><img src="/2022/06/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Automated-Generation-of-Constraints-from-Use-Case-Specifications-to-Support-System-Testing/image-20220625173337030.png" alt="image-20220625173337030"></p>
<p>可能有多个候选因为选择了多种规则</p>
<p>最高分赋予使用了用例步中最多可用信息的?</p>
<h1 id="OCL约束的格式"><a href="#OCL约束的格式" class="headerlink" title="OCL约束的格式"></a>OCL约束的格式</h1><p>一般就是比较笨蛋的 前置条件与条件步通常就是安全检查确保环境恰当，较容易捕获赋值，相等和不等关系</p>
<p><img src="/2022/06/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Automated-Generation-of-Constraints-from-Use-Case-Specifications-to-Support-System-Testing/image-20220625181049650.png" alt="image-20220625181049650"></p>
<p>是这样一套简化的EBNF 其中不少东西都是来自领域模型的，如类名和属性**</p>
<h1 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h1><p>所有转换规则共享相同的规则 每个规则和一组动词关联，如果一个动词出现，就执行一个步骤</p>
<p>在第X部分会讨论规则对英语（动词）的覆盖性，在这一部分主要讨论动词 be set enable的规则</p>
<p>SRL会识别出 左手边变量 left-hand side variable，操作符，选择元素和右手边变量right-hand side terms.</p>
<p>A1一般就是lhs varible</p>
<p>有两种转换规则：</p>
<ul>
<li><p>specific verb transformation rule: 对每个动词定制的转换规则</p>
</li>
<li><p>META verb transformation rule: 对任何动词使用的转换规则，</p>
<p>这种规则基于这样一种常见的现象 ，就是语句的LHSvarible是一个名称与其动词匹配或相同的属性(后面还会介绍)</p>
</li>
</ul>
<h1 id="VI-识别要用到OCL左侧的变量"><a href="#VI-识别要用到OCL左侧的变量" class="headerlink" title="VI 识别要用到OCL左侧的变量"></a>VI 识别要用到OCL左侧的变量</h1><p>真没搞懂在干嘛</p>
<h1 id="VII-识别右侧的变量"><a href="#VII-识别右侧的变量" class="headerlink" title="VII 识别右侧的变量"></a>VII 识别右侧的变量</h1><p>根据左侧变量的类型 支持角色来在输入的自然语言和模型中寻找类似的或可匹配到的</p>
<h1 id="VIII-识别操作符"><a href="#VIII-识别操作符" class="headerlink" title="VIII 识别操作符"></a>VIII 识别操作符</h1><p>用了别人的方法[35] 普遍都是类似于 be这样的动词</p>
<p>对于 除了……都……这样的范式 发明了一套方法 也是和语义角色标记有关系的</p>
<h1 id="IX-打分"><a href="#IX-打分" class="headerlink" title="IX 打分"></a>IX 打分</h1><p>从完整性和正确性两个维度</p>
<p>完整性：自然语言中所有概念被说明的程度有关。——用例中角色在OCL中出现的百分比</p>
<p>正确性：OCL中的变量名和用例中的名字一致</p>
<p><img src="/2022/06/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Automated-Generation-of-Constraints-from-Use-Case-Specifications-to-Support-System-Testing/image-20220625212958549.png" alt="image-20220625212958549"></p>
<h1 id="X-完整性和普遍性"><a href="#X-完整性和普遍性" class="headerlink" title="X 完整性和普遍性"></a>X 完整性和普遍性</h1><p>为了让更多的动词可以用：</p>
<ul>
<li>使用Verbnet 让同一规则可以用于更多词（同一类的词）</li>
<li>排除了形容人的感受&#x2F;行为&#x2F;动物行为的词</li>
</ul>
<p>经过分析，33个转换规则就可以给87类词转换 目前实现了7类规则 包括元转换规则。可以处理408个动词</p>
<h1 id="XI-经验评估"><a href="#XI-经验评估" class="headerlink" title="XI 经验评估"></a>XI 经验评估</h1><p>RQ1: 生成的OCL约束对吗？</p>
<p>RQ2: 对于用例规范 oclgen的自动生成效果如何？</p>
<p>RQ3: 限制生成效率的要素是什么？</p>
<h2 id="RQ1-生成的OCL约束对吗？"><a href="#RQ1-生成的OCL约束对吗？" class="headerlink" title="RQ1: 生成的OCL约束对吗？"></a>RQ1: 生成的OCL约束对吗？</h2><p>比较了生成的和手动写的</p>
<p>可能会： </p>
<ul>
<li>生成对的</li>
<li>生成错的</li>
<li>没有结果</li>
</ul>
<p>总正确率：66&#x2F;69&#x2F;87</p>
<h2 id="RQ2-对于用例规范-oclgen的自动生成效果如何？"><a href="#RQ2-对于用例规范-oclgen的自动生成效果如何？" class="headerlink" title="RQ2: 对于用例规范 oclgen的自动生成效果如何？"></a>RQ2: 对于用例规范 oclgen的自动生成效果如何？</h2><p>66&#x2F;87</p>
<h2 id="RQ3-限制生成效率的要素是什么？"><a href="#RQ3-限制生成效率的要素是什么？" class="headerlink" title="RQ3: 限制生成效率的要素是什么？"></a>RQ3: 限制生成效率的要素是什么？</h2><p>手动检查没有生成的句子</p>
<ul>
<li>信息不足</li>
<li>在用例规范和领域模型中表述不一样（is valid ——翻译不成——&lt;&gt;Error)</li>
</ul>
<h1 id="Threats-to-Validity"><a href="#Threats-to-Validity" class="headerlink" title="Threats to Validity"></a>Threats to Validity</h1><p>普遍性：只试了这个工业案例 BodySensetM</p>
<h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>自动生成可执行测试案例需要需求规格用CNL（只有有限的动词）写</p>
<p>OCLgen不需要受限的语言，而是RUCM，他引入了一些关键字，但并不限定使用的动名词</p>
<p>NL2OCL </p>
<p>处理UML类图和NL需求来得出类不变性和前后置条件，也用语义分析 来确定角色，靠侦测特定的关键字来确定被动语态或操作符</p>
<p>缺点：</p>
<p>   没有简化众多的动词怎么办——OCLgen的meta verb rule</p>
<p>已经没法拿来比较了 </p>
<p>NL2OCL更能抽取包括简单比较操作符的类不变量，而非生成前后置条件——这个对于测试用例生成更有用</p>
<p>提点问题：</p>
<ul>
<li><p>如何评估生成的OCL的质量？</p>
</li>
<li><p>在回答RQ时，使用了——产生了多少个OCL约束中多少个是正确的——没有给出“正确”的定义</p>
</li>
<li><p>此外 还评估了一下87个需求多少个能生成出来</p>
</li>
<li><p>在进行选择时，使用了打分机制，</p>
</li>
<li></li>
<li><p>输入输出是什么？</p>
</li>
</ul>
<p>输入包括两部分：</p>
<ul>
<li>RUCM格式的自然语言撰写的用例步骤</li>
</ul>
<img src="/2022/06/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Automated-Generation-of-Constraints-from-Use-Case-Specifications-to-Support-System-Testing/image-20220626184416896.png" alt="image-20220626184416896">

<ul>
<li>类图</li>
</ul>
<img src="/2022/06/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Automated-Generation-of-Constraints-from-Use-Case-Specifications-to-Support-System-Testing/image-20220626184653142.png" alt="image-20220626184653142" style="zoom: 25%;">

<p>输出似乎是有限的一种范式？</p>
<img src="/2022/06/20/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Automated-Generation-of-Constraints-from-Use-Case-Specifications-to-Support-System-Testing/image-20220626184748233.png" alt="image-20220626184748233" style="zoom:25%;">





<ul>
<li><p>创新点在哪？</p>
</li>
<li><p>借鉴 比较在哪</p>
</li>
<li><p>他做了什么事？方法是什么？</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Substance</category>
      </categories>
      <tags>
        <tag>Code generation</tag>
        <tag>ICST</tag>
        <tag>OCL</tag>
      </tags>
  </entry>
</search>
